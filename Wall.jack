/** Wall class that manages the targets */
class Wall {
    field Array targets;       // Array of targets
    field Array targetTypes;   // Type of each target (1=Circle, 2=Square, etc.)
    field Array targetX;       // X position of each target
    field Array targetY;       // Y position of each target
    field Array targetActive;  // Whether each target is active
    field int maxTargets;      // Maximum number of targets
    field int activeTargets;   // Current number of active targets
    field boolean starActive;  // Track if star is active
    field Array targetDX;      // X direction of movement (-1, 0, 1)
    field Array targetDY;      // Y direction of movement (-1, 0, 1)
    field int moveSpeed;       // Movement speed of targets
    field boolean heartActive;  // Track if heart is active
    
    // Slight change
    constructor Wall new() {    
        let maxTargets = 10;
        let targets = Array.new(maxTargets);
        let targetTypes = Array.new(maxTargets);
        let targetX = Array.new(maxTargets);
        let targetY = Array.new(maxTargets);
        let targetActive = Array.new(maxTargets);
        let targetDX = Array.new(maxTargets);
        let targetDY = Array.new(maxTargets);
        let activeTargets = 0;
        let starActive = false;
        let moveSpeed = 1;
        let heartActive = false;
        return this;
    }
    

    // Modified
    /** Initializes the wall with targets */
    method void initialize() {
        var int i;
        let i = 0;
        let activeTargets = 0;
        let starActive = false;
        
        // Clear all existing targets
        while (i < maxTargets) {
            let targetActive[i] = false;
            let i = i + 1;
        }
        
        // Generate new targets
        let i = 0;
        while (i < 5) {  // Generate 5 initial targets
            let targetTypes[i] = Random.randRange(4) + 1;
            do getValidPosition(i);
            let targetActive[i] = true;
            do drawTarget(i);
            let activeTargets = activeTargets + 1;
            let i = i + 1;
        }
        return;
    }


    // Modified
    /** Adds a star bonus target */
    method void addStar() {
        var int i;
        let i = 0;
        
        while (i < maxTargets) {
            if (~targetActive[i]) {
                let targetTypes[i] = 5;  // 5 = Star
                do getValidPosition(i);
                let targetActive[i] = true;
                do drawTarget(i);
                let activeTargets = activeTargets + 1;
                let starActive = true;
                return;
            }
            let i = i + 1;
        }
        return;
    }
    

    // Already present
    /** Checks if current round is complete */
    method boolean isRoundComplete() {
        var boolean complete;
        let complete = (activeTargets = 0);
        return complete & (~starActive);
    }
    

    // Modified
    /** Draws a specific target */
    method void drawTarget(int index) {
        var int type, x, y, size;
        
        if ((index < 0) | (index > maxTargets)) {
            return; // Index out of bounds, exit the method
        }
        
        let type = targetTypes[index];
        let x = targetX[index];
        let y = targetY[index];
        let size = 15;  // Default size
        
        do Screen.setColor(true);
        
        if (type = 1) {  // Circle
            do Screen.drawCircle(x, y, size);
        }
        if (type = 2) {  // Square
            do Screen.drawRectangle(x - size, y - size, x + size, y + size);
        }
        if (type = 3) {  // Triangle
            do drawTriangle(x, y, size);
        }
        if (type = 4) {  // Diamond
            do drawDiamond(x, y, size);
        }
        if (type = 5) {  // Star (bonus)
            do drawStar(x, y, size);
        }
        if (type = 6) {  // Heart (bonus)
            do drawHeart(x, y, size);
        }
        return;
    }
    
    
    // Already present
    /** Draws a triangle */
    method void drawTriangle(int x, int y, int size) {
        do Screen.drawLine(x, y - size, x - size, y + size);
        do Screen.drawLine(x - size, y + size, x + size, y + size);
        do Screen.drawLine(x + size, y + size, x, y - size);
        return;
    }


    // Already present    
    /** Draws a diamond */
    method void drawDiamond(int x, int y, int size) {
        do Screen.drawLine(x, y - size, x + size, y);
        do Screen.drawLine(x + size, y, x, y + size);
        do Screen.drawLine(x, y + size, x - size, y);
        do Screen.drawLine(x - size, y, x, y - size);
        return;
    }


    // Already present    
    /** Draws a star */
    method void drawStar(int x, int y, int size) {
        var int s;
        let s = size;
        
        // Outer points
        do Screen.drawLine(x, y - s, x + (s / 3), y - (s / 3));
        do Screen.drawLine(x + (s / 3), y - (s / 3), x + s, y);
        do Screen.drawLine(x + s, y, x + (s / 3), y + (s / 3));
        do Screen.drawLine(x + (s / 3), y + (s / 3), x, y + s);
        do Screen.drawLine(x, y + s, x - (s / 3), y + (s / 3));
        do Screen.drawLine(x - (s / 3), y + (s / 3), x - s, y);
        do Screen.drawLine(x - s, y, x - (s / 3), y - (s / 3));
        do Screen.drawLine(x - (s / 3), y - (s / 3), x, y - s);
        
        return;
    }

    /** Draws a heart */
    method void drawHeart(int x, int y, int size) {
        var int i;
        // Draw outline for better visibility
        do Screen.drawRectangle(x - (size/2), y, x + (size/2), y + size);  // Center
        do Screen.drawLine(x - size, y, x - (size/2), y - (size/2));       // Left arc
        do Screen.drawLine(x + (size/2), y - (size/2), x + size, y);       // Right arc
        do Screen.drawLine(x - size, y, x, y + size);                      // Left diagonal
        do Screen.drawLine(x + size, y, x, y + size);                      // Right diagonal
        return;
    }

    /** Modified spawn position for heart */
    method void spawnHeart(int lives) {
        var int i;
        if ((~heartActive) & (lives < 3)) {
            let i = 0;
            while (i < maxTargets) {
                if (~targetActive[i]) {
                    let targetTypes[i] = 6;  // 6 = Heart
                    // Place heart in more visible location
                    let targetX[i] = 50 + Random.randRange(400); // Random X between 50-450
                    let targetY[i] = 50 + Random.randRange(100); // Random Y between 50-150
                    let targetActive[i] = true;
                    let heartActive = true;
                    do drawTarget(i);
                    let activeTargets = activeTargets + 1;
                    return;
                }
                let i = i + 1;
            }
        }
        return;
    }

    /** Adds a heart bonus target */
    method void addHeart() {
        var int i;
        let i = 0;
        
        while (i < maxTargets) {
            if (~targetActive[i]) {
                let targetTypes[i] = 6;  // 6 = Heart
                do getValidPosition(i);
                let targetActive[i] = true;
                do drawTarget(i);
                let activeTargets = activeTargets + 1;
                return;
            }
            let i = i + 1;
        }
        return;
    }

    // Slightly Modified
    /** Checks if a shot hits a target */
    method int checkHit(int gunX) {
        var int i, tX, tY, type, distance, hitType;
        let i = 0;
        let hitType = 0;
        
        while (i < maxTargets) {
            if (targetActive[i]) {
                let tX = targetX[i];
                let tY = targetY[i];
                let type = targetTypes[i];
                
                if (gunX > tX) {
                    let distance = gunX - tX;
                } else {
                    let distance = tX - gunX;
                }
                
                if (distance < 20) {  // Hit threshold
                    do clearTarget(i);
                    let targetActive[i] = false;
                    let activeTargets = activeTargets - 1;
                    let hitType = type;
                    if (type = 5) { // Star hit
                        let starActive = false;
                    }
                    if (type = 6) { // Heart hit
                        let heartActive = false;
                    }
                    
                    return hitType;
                }
            }
            let i = i + 1;
        }
        return 0;
    }
    

    // slightly modified
    /** Clears a target from the screen */
    method void clearTarget(int index) {
        var int type, x, y, size;
        
        let type = targetTypes[index];
        let x = targetX[index];
        let y = targetY[index];
        let size = 15;  // Default size
        
        do Screen.setColor(false);
        
        if (type = 1) {  // Circle
            do Screen.drawCircle(x, y, size);
        }
        if (type = 2) {  // Square
            do Screen.drawRectangle(x - size, y - size, x + size, y + size);
        }
        if (type = 3) {  // Triangle
            do drawTriangle(x, y, size);
        }
        if (type = 4) {  // Diamond
            do drawDiamond(x, y, size);
        }
        if (type = 5) {  // Star (bonus)
            do drawStar(x, y, size);
        }
        if (type = 6) {  // Heart (bonus)
            do drawHeart(x, y, size);
        }
        return;
    }
    

    /** Regenerates targets */
    method void regenerateTargets() {
        var int i;
        let i = 0;
        
        while (i < maxTargets) {
            if (~targetActive[i]) {
                let targetTypes[i] = Random.randRange(4) + 1;
                do getValidPosition(i);
                let targetActive[i] = true;
                do drawTarget(i);
                let activeTargets = activeTargets + 1;
            }
            let i = i + 1;
        }
        return;
    }
    
    /** Checks if a position would overlap with existing targets */
    method boolean isOverlapping(int newX, int newY, int index) {
        var int i, otherX, otherY, distance;
        let i = 0;
        
        while (i < maxTargets) {
            if (~((i = index) | (~targetActive[i]))) {  // Inverted condition to replace continue
                let otherX = targetX[i];
                let otherY = targetY[i];
                
                // Calculate distance between points
                if (newX > otherX) {
                    let distance = newX - otherX;
                } else {
                    let distance = otherX - newX;
                }
                
                // Check Y distance too
                if ((distance < 40) & 
                    (Math.abs(newY - otherY) < 40)) {
                    return true;  // Overlap detected
                }
            }
            let i = i + 1;
        }
        return false;
    }

    /** Modified getValidPosition to include movement direction */
    method void getValidPosition(int index) {
        var int attempts, newX, newY;
        let attempts = 0;
        
        while (attempts < 10) {  // Limit attempts to prevent infinite loop
            let newX = 50 + (Random.randRange(9) * 45);
            let newY = 50 + (Random.randRange(4) * 30);
            
            if (~isOverlapping(newX, newY, index)) {
                let targetX[index] = newX;
                let targetY[index] = newY;
                
                // Set random movement direction
                let targetDX[index] = Random.randRange(3) - 1;  // -1, 0, or 1
                let targetDY[index] = Random.randRange(3) - 1;  // -1, 0, or 1
                return;
            }
            let attempts = attempts + 1;
        }
        
        // If no good position found, place at default position with offset
        let targetX[index] = 50 + (index * 80);
        let targetY[index] = 50 + (index * 40);
        
        // Set random movement direction
        let targetDX[index] = Random.randRange(3) - 1;  // -1, 0, or 1
        let targetDY[index] = Random.randRange(3) - 1;  // -1, 0, or 1
        return;
    }
    
    /** Updates target positions based on current level */
    method void updateTargets(int level, int lives) {
        var int i, oldX, oldY;
        let i = 0;

        // Check and spawn heart bonus shape
        do spawnHeart(lives);

        if (level > 1) {  // Only move targets in level 2+
            while (i < maxTargets) {
                if (targetActive[i]) {
                    // Store old position
                    let oldX = targetX[i];
                    let oldY = targetY[i];
                    
                    // Calculate new position
                    let targetX[i] = targetX[i] + (targetDX[i] * moveSpeed);
                    let targetY[i] = targetY[i] + (targetDY[i] * moveSpeed);
                    
                    // Bounce off screen edges
                    if ((targetX[i] < 30) | (targetX[i] > 480)) {
                        let targetDX[i] = -targetDX[i];
                        let targetX[i] = oldX;  // Revert to old position
                    }
                    if ((targetY[i] < 30) | (targetY[i] > 200)) {
                        let targetDY[i] = -targetDY[i];
                        let targetY[i] = oldY;  // Revert to old position
                    }
                    
                    // Clear old position first
                    do Screen.setColor(false);
                    if (targetTypes[i] = 1) {  // Circle
                        do Screen.drawCircle(oldX, oldY, 15);
                    }
                    if (targetTypes[i] = 2) {  // Square
                        do Screen.drawRectangle(oldX - 15, oldY - 15, oldX + 15, oldY + 15);
                    }
                    if (targetTypes[i] = 3) {  // Triangle
                        do drawTriangle(oldX, oldY, 15);
                    }
                    if (targetTypes[i] = 4) {  // Diamond
                        do drawDiamond(oldX, oldY, 15);
                    }
                    if (targetTypes[i] = 5) {  // Star
                        do drawStar(oldX, oldY, 15);
                    }
                    if (targetTypes[i] = 6) {  // Heart
                        do drawHeart(oldX, oldY, 15);
                    }
                    
                    // Draw at new position
                    do Screen.setColor(true);
                    if (targetTypes[i] = 1) {  // Circle
                        do Screen.drawCircle(targetX[i], targetY[i], 15);
                    }
                    if (targetTypes[i] = 2) {  // Square
                        do Screen.drawRectangle(targetX[i] - 15, targetY[i] - 15, 
                                             targetX[i] + 15, targetY[i] + 15);
                    }
                    if (targetTypes[i] = 3) {  // Triangle
                        do drawTriangle(targetX[i], targetY[i], 15);
                    }
                    if (targetTypes[i] = 4) {  // Diamond
                        do drawDiamond(targetX[i], targetY[i], 15);
                    }
                    if (targetTypes[i] = 5) {  // Star
                        do drawStar(targetX[i], targetY[i], 15);
                    }
                    if (targetTypes[i] = 6) {  // Heart
                        do drawHeart(targetX[i], targetY[i], 15);
                    }
                }
                let i = i + 1;
            }
        }
        return;
    }

    /** Modified dispose method */
    method void dispose() {
        do targetX.dispose();
        do targetY.dispose();
        do targetTypes.dispose();
        do targetActive.dispose();
        do targetDX.dispose();
        do targetDY.dispose();
        do targets.dispose();
        do Memory.deAlloc(this);
        return;
    }
}
